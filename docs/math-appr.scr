@begin(section) @title(Math/Appr)

 @begin(section) @title(Обзор)
  Здесь под аппроксимацией понимается замена функции, заданной таблично,
  функцией или семейтсвом функций, заданных аналитически на некоторых интервалах.

 Типы аппроксимации:
 @begin(list)
  @item(полиномиальная - нескольких переменных;)
  @item(линейная - одного переменного;)
  @item(билинейная - двух переменных;)
  @item(сглаженная - одного переменного (доделать и задокументировать);)
  @item(сглаженная - двух переменных (задокументировать);)
 @end(list)

 @end(section)

 @begin(section) @title(Полиномиальная)
  Функции  @b(averaging-function-lambda), @b(averaging-function-defun) позволяют
  найти полиномиальную аппроксимирующую функцию одного или нескольких переменных.

  Для нахождения полиномиальных аппроксимаций можно воспользоваться
  @b(шаблонами аргументов) и @b(шаблонами функций).

  Макросы @b(make-approximation-lambda), @b(make-approximation-defun) позволяют
  определить аппроксимирующую функцию одного или нескольких переменных,
  представленную в виде полинома.

  @cl:with-package[name="math/appr"](
   @cl:doc(function averaging-function-lambda)
   @cl:doc(function averaging-function-defun)
   @cl:doc(macro make-approximation-lambda)
   @cl:doc(macro make-approximation-defun))
 @end(section)

 @begin(section) @title(Линейная)
  Для линейной аппроксимации функции одного переменного используйте:
  @begin(list)
   @item(функцию @b(appr-table);)
   @item(объект класса @b(<appr-linear>) и метод @b(approximate);)
   @item(функцию @b(make-appr-linear).)
  @end(list)
  @cl:with-package[name="math/appr"](
   @cl:doc(function appr-table)
   @cl:doc(class <appr-linear>)
   @cl:doc(method approximate (point number) (a-l <appr-linear>))
   @cl:doc(function make-appr-linear))
   
  @cl:with-package[name="math/appr"](
   @cl:doc(function approximation-linear)  
   @cl:doc(function make-linear-interpolation)
   @cl:doc(function make-linear-approximation-array)
  
   @cl:doc(function index-by-value)
   @cl:doc(generic approx-by-points))
 @end(section)
 
 @begin(section) @title(БиЛинейная)
  Для билинейной аппроксимации функции двух переменных используйте:
  @begin(list)
   @item(объект класса @b(<appr-bilinear>) и метод @b(approximate).)
  @end(list)
  @cl:with-package[name="math/appr"](
   @cl:doc(class <appr-bilinear>)
   @cl:doc(method approximate point (a-l <appr-bilinear>))
   @cl:doc(function approximation-bilinear)
   @cl:doc(function make-bilinear-interpolation)
   @cl:doc(function make-bilinear-approximation-array))
 @end(section)

 @begin(section) @title(Шаблоны аргументов)
  @cl:with-package[name="math/appr"](
   @cl:doc(variable *apr-args-1*)
   @cl:doc(variable *apr-args-2*))
 @end(section)

 @begin(section) @title(Шаблоны функций)
  @begin(section) @title(Одного переменного)
   @cl:with-package[name="math/appr"](
    @cl:doc(variable *apr-func-1-2*)
    @cl:doc(variable *apr-func-1-3*)
    @cl:doc(variable *apr-func-1-4*)
    @cl:doc(variable *apr-func-1-5*))
  @end(section)
  @begin(section) @title(Двух переменных)
   @cl:with-package[name="math/appr"](
    @cl:doc(variable *apr-func-2-4*)
    @cl:doc(variable *apr-func-2-5*)
    @cl:doc(variable *apr-func-2-6*)
    @cl:doc(variable *apr-func-2-7*)
    @cl:doc(variable *apr-func-2-8*)
    @cl:doc(variable *apr-func-2-9*))
  @end(section)
 @end(section)
 
 @begin(section) @title(Сглаженная)
  Для нахождения значений сглаженной зависимости можно
  использовать метод @b(smooth-by-points) или метод
  @b(make-smooting), возвращающий замыкание.

  Сглаженная зависимость не проходит через, точки определяющие ее.

  Для нахождения зависимости, примерно проходящие через точки
  (определяющие ее), можно использовать метод @b(refine-smoothing-by-points)
  или метод @b(make-refine-smooting), возвращающий замыкание.
  
  @begin(section) @title(Обобщенные функции)
   @cl:with-package[name="math/appr"](
    @cl:doc(generic smooth-by-points)
    @cl:doc(generic refine-smoothing-by-points))
  @end(section)
  
  @begin(section) @title(Методы)
   @cl:with-package[name="math/appr"](
    @cl:doc(method smooth-by-points (x number) (dx number) (points vector) (values vector) &key (weight-func #'math/smooth:gauss-smoothing))
    @cl:doc(method smooth-by-points (x vector) (dx vector) (points array) (values vector) &key (weight-func #'math/smooth:gauss-smoothing))
    
    @cl:doc(method refine-smoothing-by-points (nod-points vector) (nod-values vector) (base-dist-s number) &key (weight-func #'math/smooth:gauss-smoothing) (delta 0.001) (iterations 10000))
    @cl:doc(method refine-smoothing-by-points (nod-points array) (nod-values vector) (base-dist-s vector) &key (weight-func #'math/smooth:gauss-smoothing) (delta 0.001) (iterations 10000))
    
    @cl:doc(method make-refine-smooting (nod-points array) (nod-values vector) (base-dist-s vector) &key (weight-func #'math/smooth:gauss-smoothing) (delta 0.001) (iterations 10000))
    @cl:doc(method make-refine-smooting (nod-points vector) (nod-values vector) (base-dist-s number) &key (weight-func #'math/smooth:gauss-smoothing) (delta 0.001) (iterations 10000))
    )
  @end(section)
 @end(section)
@end(section)

